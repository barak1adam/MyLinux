Each thread includes a unique program counter, process stack, and set of proces-
sor registers.

It is often useful for the kernel to perform some operations in the background.The ker-
nel accomplishes this via kernel threadsâ€”standard processes that exist solely in kernel-
space.The significant difference between kernel threads and normal processes is that 
kernel threads do not have an address space. (Their mm pointer, which points at their address space, is NULL.)
They operate only in kernel-space and do not context switch into user-space. 
Kernel threads, however, are schedulable and preemptable, the same as normal processes.

Linux delegates several tasks to kernel threads, most notably the flush tasks and the 
ksoftirqd task.You can see the kernel threads on your Linux system by running the com-
mand ps -ef.There are a lot of them! 

Upon returning to user-space or returning from an interrupt, the need_resched 
flag is checked. If it is set, the kernel invokes the scheduler before continuing.
The flag is per-process, and not simply global, because it is faster to access a value in 
the process descriptor (because of the speed of current and high probability of it being 
cache hot) than a global variable.

Consequently, whenever the kernel is preparing to return to user-space either on return from an interrupt or after a sys-
tem call, the value of need_resched is checked. If it is set, the scheduler is invoked to 
select a new (more fit) process to execute.

In short, user preemption can occur
====================================
1. When returning to user-space from a system call
2. When returning to user-space from an interrupt handler


kernel is preemptive:

In nonpreemptive kernels, kernel code runs until completion

now kernel code (running by any task: running drivers code on behalf of user threads, kthreads, etc) can be preempted.

The kernel can preempt a task running in the kernel 
so long as it does not hold a lock.

In short, kernel preemptin can occur:
=====================================
1. When interrupt handler exists, before returning to kernel space
2. when kernel code becomes preemptive again (preempt count = 0 meaning no lock is held and resched is set)
3. if a task in the kernel space explicitly calls schedule()
4. if a task in the kernel blocks (which results in a call to schedule())


Hardware interrupts are issued by hardware devices like disk, network cards, keyboards, clocks, etc. Each device or set of devices will have its own IRQ (Interrupt ReQuest) line.
The driver which handles the interrupt is run on the CPU. The CPU is interrupted from what it was doing to handle the interrupt
The hardware interrupt interrupts the CPU directly. This will cause the relevant code in the kernel process to be triggered. 

Software interrupts are processed much like hardware interrupts. However, they can only be generated by processes which are currently running.
It is correct that a software interrupt doesn't directly interrupt the CPU. Only code that is currently running code can generate a software interrupt.
The software interrupt only talks to the kernel.
Typically software interrupts are requests for I/O (Input or Output). These will call kernel routines which will schedule the I/O to occur.
the process may be suspended until the I/O completes, causing the kernel scheduler to select another process to run
