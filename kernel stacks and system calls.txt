kernel stacks and system calls

each process has 2 stacks:
1. a user space stack, located in the user space memory for that process (shrinking in size, max size is defined in rlimit)
2. a kernel space stack, located in the kernel memory (fixed size). user stack pointer is saved.

#################
slide 25 chester
slide 1 gabriel
################

user stack is accessible both for the usr and for the kernel
kernel stack is accessible just for the kernel.

1. kernel stack for each process:
all architectures have a kernel stack for every active thread
size = THREAD_SIZE (2*PAGE_SIZE)
One per thread.
These stacks contain useful data as long as a thread is alive or a
zombie. While the thread is in user space the kernel stack is empty
except for the thread_info structure at the bottom

active kernel stack is pointed by TSS (TSS->esp0)

####################################
thread_info / task_struct, wikipedia
####################################

2. Interrupt stack
Used for external hardware interrupts.
one per CPU.
size = IRQ_STACK_SIZE.
The interrupt stack is also used when processing a softirq.

3. Exception stack (NMI_STACK).  
Used for non-maskable interrupts (NMI) = exceptions.
size = EXCEPTION_STKSZ (PAGE_SIZE)
one per CPU.

More stacks, out of the scope of this discussion:
4. Double fault stack (DOUBLEFAULT_STACK)
Used for interrupt 8 - Double Fault Exception (#DF).
Invoked when handling one exception causes another exception
size = EXCEPTION_STKSZ (PAGE_SIZE)
one per CPU

5. Debug stack (DEBUG_STACK)
Used for hardware debug interrupts (interrupt 1) and for software debug interrupts (INT3).
size = DEBUG_STKSZ
one per CPU

6. Machine Check Exception stack (MCE_STACK)
Used for interrupt 18 - Machine Check Exception (#MC).
size = EXCEPTION_STKSZ (PAGE_SIZE)
one per CPU

Barak:
system calls and kernel threads are using the kernel stack of the current process.
hw interrupts are handled on the interrupts stack (since kernel 2.6)

system calls are sleepable and can be interrupted. 
hw interrupts are not sleepable but are nested.

nested interrupts:
-------------------
interrupts are nested by other IRQs, not by the current IRQ which is usually disabled in the PIC.
It is important to mention that Disabled interrupts are not lost; the PIC sends them to the CPU as soon as they are enabled again.
(This feature is used by most interrupt handlers since it allows them to process IRQs of the same type serially)

Robert Love(p.119):
Interrupt handlers in Linux need not be reentrant. When a given interrupt handler is execut-
ing, the corresponding interrupt line is masked out on all processors, preventing another 
interrupt on the same line from being received. Normally all other interrupts are enabled, so 
other interrupts are serviced, but the current line is always disabled.

Looking into the HW handling of interrupts, we can conclude that upon nesting interrupts, a priveledge mode
is not changed and user context is not required to be save again on the stack.
Just eflags, cs, and eip (current handler) are saved and the new cs and eip are loaded as
pointed by the IDT entry of the new handler.
(look at step 7, Hardware Handling of Interrupts and Exceptions, Understanding the Linux Kernel)

An interrupt handler may preempt both other interrupt handlers and exception handlers.
Conversely, an exception handler never preempts an interrupt handler. 
The only exception that can be triggered in Kernel Mode is Page Fault, which we just described. 
But interrupt handlers never perform operations that can induce Page Faults, and thus, potentially, process switch. 

System calls:
=============

user space calls C API fucntion, system call wrapper.
########################
figure 5.1 robert love
chester slide 53
#######################
the wrapper set eax with the syscall number and invoke a syscall instruction for the CPU.
the syscall instruction is SW interrupts = exception.
(SW interrupt is synchronous to CPU, versus HW interrupsts which are asynchronous)
#######################
explain sw interrupts / hw interrupts
#######################

SW interrupts are generated by instruction INT n (n = interrupt number)
A software interrupt is raised by executing a piece of code.
On x86-64 systems, a software interrupt can be raised by executing the int instruction.

Interrupts usually have numbers assigned to them (n). Some of these interrupt numbers have a special meaning.
For system calls n = 0x80.

You can imagine an array that lives in memory on the CPU. 
Each entry in this array maps to an interrupt number. 
Each entry contains the address of a function that the CPU will begin executing when that interrupt is received 
along with some options, like what privilege level the interrupt handler function should be executed in.

System calls are implemented as SW interrupt #80 and not by NMI.
we can see it in trap_init(): different IDT entries are allocated to NMI and to system calls:
set_intr_gate_ist(X86_TRAP_NMI, &nmi, NMI_STACK);
....
set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32);




CPU handling of the exception:
------------------------------
1. switch to kernel stack (active kernel stack is pointed by TSS)
upon the excetpion - CPU moves into priviledge mode.
CPU switch automatically to kernel stack.
#############
why to switch to kernel stack? chester slide 26
##############

2. save user space thread basic state on this kernel stack
X86 saves the following registers on the kernel stack:
SS
ESP (user stack pointer)
EFLAGS
CS
EIP (user program/text pointer)
error code on stack

3. CPU jumps to exception handler automatically.
using the IDT in memory 
#########################
chester slide 31
#########################
exception handler is system_call
system_call is executed on the kernel stack of the calling process.
-save all registers on kernel thread stack (all registers except those aready saved by the CPU automaticall)
-test the specific sys call number
-jump to the specific sys call.

after the specific handler is ended, system_call calls IRET instruction:
it pop the saved registers from the stacks into registers (those saved by INT instruction) and resumes execution
at the saved EIP.


Another detailed description of INT:
=====================================
Fetch the n’th descriptor from the IDT, where n is the argument of int.
Check  that  CPL  in %cs is  <=  DPL,  where  DPL  is  the  privilege  level  in  the  de-scriptor.
Save %esp and %ss in  a  CPU-internal  registers,  but  only  if  the  target  segment  se-lector’s  PL  <  CPL.
Load %ssand%espfrom  a  task  segment  descriptor.
Push %ss.
Push %esp.
Push %eflags.
Push %cs.
Push %eip.
Clear some  bits  of%eflags.
Set %cs and %eipto the values in the descriptor.

The Operation of an Interrupt sequence on the 6800 Microprocessor:

1. The CPU finishes the present instruction.

2. The return address High Byte is Pushed onto the Stack.  

3. The Stack Pointer (SP) is decremented

4. The return address Low Byte is Pushed onto the Stack

5. The Stack Pointer (SP) is decremented

6. The microprocessor services the Interrupt Service Routine (ISR).

7. While returning from the interrupt-service routine by the instruction (RTI) the return address Low and High bytes are Pulled from the stack and placed into the Programme Counter (PC).

8. Main programme continues.


Non-Maskable Interrupts

There are some interrupts which cannot be masked out or ignored by the processor. These are associated with high priority tasks which cannot be ignored (like memory parity or bus faults).
In general, most processors support the Non-Maskable Interrupt (NMI). 
This interrupt has absolute priority, and when it occurs, the processor will finish the current memory cycle, then branch to a special routine written to handle the interrupt request. 

Software Interrupt

The Software Interrupt (SWI) is an instruction that can be placed anywhere within a programme. 
It forces the microprocessor to act as if an interrupt has occurs.

Interrupt Latency

The time interval from when the interrupt is first asserted to the time the CPU recognises it. This will depend much upon whether interrupts are diasbled,prioritized and what the processor is currently executing.

At times, a processor might ignore requests whilst executing an instruction stream (read-write-modify cycle). The figure that matters most is the longest possible interrupt latency time.
Interrupt Response Time

The time interval between the CPU recognising the interrupt to the time when the first instruction of the interrupt service routine is executed. This is determined by the processor architecture and clock speed. 




next:
document also hw interrupts
document also context switch gabriel
